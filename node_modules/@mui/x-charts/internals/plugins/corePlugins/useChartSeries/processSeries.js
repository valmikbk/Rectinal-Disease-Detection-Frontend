"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultizeSeries = exports.applySeriesProcessors = exports.applySeriesLayout = void 0;
/**
 * This method groups series by type and adds defaultized values such as the ids and colors.
 * It does NOT apply the series processors - that happens in a selector.
 * @param series The array of series provided by the developer
 * @param colors The color palette used to defaultize series colors
 * @returns An object structuring all the series by type with default values.
 */
const defaultizeSeries = ({
  series,
  colors,
  seriesConfig
}) => {
  // Group series by type
  const seriesGroups = {};
  series.forEach((seriesData, seriesIndex) => {
    const seriesWithDefaultValues = seriesConfig[seriesData.type].getSeriesWithDefaultValues(seriesData, seriesIndex, colors);
    const id = seriesWithDefaultValues.id;
    if (seriesGroups[seriesData.type] === undefined) {
      seriesGroups[seriesData.type] = {
        series: {},
        seriesOrder: []
      };
    }
    if (seriesGroups[seriesData.type]?.series[id] !== undefined) {
      throw new Error(`MUI X Charts: series' id "${id}" is not unique.`);
    }
    seriesGroups[seriesData.type].series[id] = seriesWithDefaultValues;
    seriesGroups[seriesData.type].seriesOrder.push(id);
  });
  return seriesGroups;
};

/**
 * Applies series processors to the defaultized series groups.
 * This should be called in a selector to compute processed series on-demand.
 * @param defaultizedSeries The defaultized series groups
 * @param seriesConfig The series configuration
 * @param dataset The optional dataset
 * @returns Processed series with all transformations applied
 */
exports.defaultizeSeries = defaultizeSeries;
const applySeriesProcessors = (defaultizedSeries, seriesConfig, dataset) => {
  const processedSeries = {};

  // Apply formatter on a type group
  Object.keys(seriesConfig).forEach(type => {
    const group = defaultizedSeries[type];
    if (group !== undefined) {
      processedSeries[type] = seriesConfig[type]?.seriesProcessor?.(group, dataset) ?? group;
    }
  });
  return processedSeries;
};

/**
 * Applies series processors with drawing area to series if defined.
 * @param processedSeries The processed series groups
 * @param seriesConfig The series configuration
 * @param drawingArea The drawing area
 * @returns Processed series with all transformations applied
 */
exports.applySeriesProcessors = applySeriesProcessors;
const applySeriesLayout = (processedSeries, seriesConfig, drawingArea) => {
  let processingDetected = false;
  const seriesLayout = {};

  // Apply processors on series type per group
  Object.keys(processedSeries).forEach(type => {
    const processor = seriesConfig[type]?.seriesLayout;
    const thisSeries = processedSeries[type];
    if (processor !== undefined && thisSeries !== undefined) {
      const newValue = processor(thisSeries, drawingArea);
      if (newValue && newValue !== processedSeries[type]) {
        processingDetected = true;
        seriesLayout[type] = newValue;
      }
    }
  });
  if (!processingDetected) {
    return {};
  }
  return seriesLayout;
};
exports.applySeriesLayout = applySeriesLayout;