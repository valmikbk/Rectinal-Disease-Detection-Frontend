import { stackOrderNone as d3StackOrderNone, stackOrderReverse as d3StackOrderReverse, stackOrderAppearance as d3OrderAppearance, stackOrderAscending as d3OrderAscending, stackOrderDescending as d3OrderDescending, stackOrderInsideOut as d3OrderInsideOut, stackOffsetExpand as d3StackOffsetExpand, stackOffsetNone as d3StackOffsetNone, stackOffsetSilhouette as d3StackOffsetSilhouette, stackOffsetWiggle as d3StackOffsetWiggle, type Series } from '@mui/x-charts-vendor/d3-shape';
import type { StackOffsetType, StackOrderType } from "../../models/stacking.js";
import { type SeriesId, type StackableSeriesType } from "../../models/seriesType/common.js";
type FormatterParams<T> = {
  series: Record<SeriesId, T>;
  seriesOrder: SeriesId[];
  defaultStrategy?: {
    stackOrder?: StackOrderType;
    stackOffset?: StackOffsetType;
  };
};
export type StackingGroupsType = {
  ids: SeriesId[];
  stackingOrder: (series: Series<any, any>) => number[];
  stackingOffset: (series: Series<any, any>, order: Iterable<number>) => void;
}[];
export declare const StackOrder: {
  /**
   * Series order such that the earliest series (according to the maximum value) is at the bottom.
   * */
  appearance: typeof d3OrderAppearance;
  /**
   *  Series order such that the smallest series (according to the sum of values) is at the bottom.
   * */
  ascending: typeof d3OrderAscending;
  /**
   * Series order such that the largest series (according to the sum of values) is at the bottom.
   */
  descending: typeof d3OrderDescending;
  /**
   * Series order such that the earliest series (according to the maximum value) are on the inside and the later series are on the outside. This order is recommended for streamgraphs in conjunction with the wiggle offset. See Stacked Graphs—Geometry & Aesthetics by Byron & Wattenberg for more information.
   */
  insideOut: typeof d3OrderInsideOut;
  /**
   * Given series order [0, 1, … n - 1] where n is the number of elements in series. Thus, the stack order is given by the key accessor.
   */
  none: typeof d3StackOrderNone;
  /**
   * Reverse of the given series order [n - 1, n - 2, … 0] where n is the number of elements in series. Thus, the stack order is given by the reverse of the key accessor.
   */
  reverse: typeof d3StackOrderReverse;
};
export declare const StackOffset: {
  /**
   * Applies a zero baseline and normalizes the values for each point such that the topline is always one.
   * */
  expand: typeof d3StackOffsetExpand;
  /**
   * Positive values are stacked above zero, negative values are stacked below zero, and zero values are stacked at zero.
   * */
  diverging: (series: Series<any, any>, order: Iterable<number>) => void;
  /**
   * Applies a zero baseline.
   * */
  none: typeof d3StackOffsetNone;
  /**
   * Shifts the baseline down such that the center of the streamgraph is always at zero.
   * */
  silhouette: typeof d3StackOffsetSilhouette;
  /**
   * Shifts the baseline so as to minimize the weighted wiggle of layers. This offset is recommended for streamgraphs in conjunction with the inside-out order. See Stacked Graphs—Geometry & Aesthetics by Bryon & Wattenberg for more information.
   * */
  wiggle: typeof d3StackOffsetWiggle;
};
/**
 * Takes a set of series and groups their ids
 * @param series the object of all bars series
 * @returns an array of groups, including the ids, the stacking order, and the stacking offset.
 */
export declare const getStackingGroups: <T extends StackableSeriesType>(params: FormatterParams<T>) => StackingGroupsType;
export {};